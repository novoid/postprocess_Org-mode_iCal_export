#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Time-stamp: <2015-05-14 16:04:46 vk>


## TODO:
## * fix parts marked with «FIXXME»
## * fix: all lines with no iCal tag followed by ':' are extended summary lines and should follow the summary line


## overrules enything else and shows only PRIVATE_SUMMARY and no location
PRIVATE_TAG = 'private'
PRIVATE_SUMMARY = 'busy'              # in case no special tag is found
MAX_DESCRIPTION_LINES = 10            # number of description lines (of input file) added to output

## ===================================================================== ##
##  You might not want to modify anything below this line if you do not  ##
##  know, what you are doing :-)                                         ##
## ===================================================================== ##

## NOTE: in case of issues, check iCalendar files using: http://icalvalid.cloudapp.net/

import os
import sys
import re
import time
import logging
from optparse import OptionParser

REMINDER_REGEX = re.compile("^rem(\d\d?)$")

TIMESTAMP_ROUGH_REGEX = re.compile("<.*>")
DTEND_REGEX = re.compile("\nDTEND(;VALUE=DATE)?:(.+)\n")
UID_REGEX = re.compile("UID:(.+)")

PROG_VERSION_NUMBER = u"0.1"
PROG_VERSION_DATE = u"2015-05-14"
INVOCATION_TIME = time.strftime("%Y-%m-%dT%H:%M:%S", time.localtime())
INVOCATION_DAY_STR = INVOCATION_TIME[:10]
INVOCATION_DAY_SHORTSTR = time.strftime("%Y%m%d", time.localtime())

USAGE = u"\n\
    " + sys.argv[0] + u" -i <inputfile.ics> -o <outputfile.ics>\n\
\n\
This script filters an iCalendar file generated by Emacs Org-mode.\n\
\n\
Entries whose DTEND is in the past are omitted.\n\
\n\
Only the first entry of identical UIDs are written.\n\
\n\
If the tag defined in PRIVATE_TAG is found, description, summary, and \n\
location gets replaced with PRIVATE_SUMMARY as summary.\n\
\n\
Additionally, if REMINDER_REGEX finds reminders in tags, a Google\n\
Calendar reminder VALARM is added.\n\
\n\
Please refer to README.org for further details.\n\
\n\
https://github.com/novoid/postprocess_Org-mode_iCal_export\n\
\n\
\n\
:copyright: (c) 2013 or later by Karl Voit <tools@Karl-Voit.at>\n\
:license: GPL v3 or any later version\n\
:bugreports: <tools@Karl-Voit.at>\n\
:version: " + PROG_VERSION_NUMBER + " from " + PROG_VERSION_DATE + "\n"

parser = OptionParser(usage=USAGE)

parser.add_option("-i", "--input", dest="inputfilename",
                  help="(path and) name of the iCalendar file to parse", metavar="FILE")

parser.add_option("-o", "--output", dest="outputfilename",
                  help="(path and) name of the iCalendar file where the result is written to", metavar="FILE")

parser.add_option("--remove-summary-timestamps", dest="removesummarytimestamps", action="store_true",
                  help="Removes any time-stamps found in summary line descriptions.")

parser.add_option("--obfuscate", dest="obfuscateeverything", action="store_true",
                  help="Hides summaries, descriptions, and categories. Generates a simple free/busy iCalendar file.")

parser.add_option("--dryrun", dest="dryrun", action="store_true",
                  help="Does not make any changes to the file system. Useful for testing behavior.")

parser.add_option("-O", "--overwrite", dest="overwrite", action="store_true",
                  help="Overwrite the output file without asking, if the output file exists.")

parser.add_option("-v", "--verbose", dest="verbose", action="store_true",
                  help="enable verbose mode")

parser.add_option("--version", dest="version", action="store_true",
                  help="display version and exit")

(options, args) = parser.parse_args()


def handle_logging():
    """Log handling and configuration"""

    if options.verbose:
        FORMAT = "%(levelname)-8s %(asctime)-15s %(message)s"
        logging.basicConfig(level=logging.DEBUG, format=FORMAT)
    else:
        FORMAT = "%(levelname)-8s %(message)s"
        logging.basicConfig(level=logging.INFO, format=FORMAT)


def error_exit(errorcode, text):
    """exits with return value of errorcode and prints to stderr"""

    sys.stdout.flush()
    logging.error(text)

    sys.exit(errorcode)


def parse_categories_for_known_tags(categories):
    """parse categories for pre-defined tags and generate new summary
    and is_private flag accordingly."""

    catlist = categories[11:].split(',')
    #logging.debug("catlist [%s]" % str(catlist) )

    is_private = False
    reminder = []

    if catlist:

        for tag in catlist:
            #logging.debug("tag [%s]" % tag )

            if PRIVATE_TAG == tag:
                is_private = True

            matching_reminder = re.match(REMINDER_REGEX, tag)
            if matching_reminder:

                reminder_minutes = matching_reminder.group(1)
                logging.debug("found reminder in tag [%s] with [%s] minutes" % (tag, reminder_minutes))
                reminder.append(reminder_minutes)

    return reminder, is_private


def generate_reminder_entries(reminderlist):
    """Generate iCalendar entries for each reminder in the list."""

    output = ""

    for reminder in reminderlist:
        output += "BEGIN:VALARM\nACTION:DISPLAY\nDESCRIPTION:This is an event reminder\n"
        output += "TRIGGER:-P0DT0H" + reminder.zfill(2) + "M0S\nEND:VALARM\n"

    return output


def dtend_is_not_in_past(entry):
    """returns true, if DTEND of VEVENT-string is today or in the future.
       Returns also true, if there is no DTEND entry."""

    matching_dtend = re.search(DTEND_REGEX, entry)
    if matching_dtend:
        return INVOCATION_DAY_SHORTSTR <= matching_dtend.group(2)[:8]
    else:
        return True


def handle_file(inputfilename, outputfilename, dryrun, obfuscate_everything):
    """handles inputfile and generates outputfile"""

    logging.debug("--------------------------------------------")
    logging.info(sys.argv[0] + "   ... called with ... ")
    logging.info("inputfile file \"" + inputfilename + "\"  ... and ...")
    logging.info("output file \"" + outputfilename + "\"")

    parsing_header = True
    count_events = 0
    omitted_events = 0
    newentry = ""
    currentsummary = ""
    currentdescription = ""
    currentcategories = ""
    currentuid = ""
    in_description = False
    in_summary = False
    description_lines = 0
    known_uids = []

    with open(outputfilename, 'w') as output:

        inputfile = open(inputfilename, 'r')
        for rawline in inputfile:

            newline = ""
            line = rawline.strip()
            logging.debug("line: %s" % line)

            ## detect new event (and header end)
            if line.startswith('BEGIN:VEVENT'):
                logging.debug("new VEVENT .............................................")
                count_events += 1
                newline = line
                in_description = False
                in_summary = False

                ## header is finished:
                if parsing_header and not dryrun:
                    output.write(newentry)
                    newentry = ""

                parsing_header = False

            ## store content fields:
            elif line.startswith('SUMMARY:'):
                in_description = False
                in_summary = True
                if options.removesummarytimestamps:
                    ## removing any substrings enclosed in angle brackets (usually time-stamps):
                    currentsummary = TIMESTAMP_ROUGH_REGEX.sub('', line).replace("SUMMARY:  ", "SUMMARY: ")
                else:
                    currentsummary = line
            elif line.startswith('DESCRIPTION:'):
                in_summary = False
                in_description = True
                description_lines = 1
                currentdescription = line
            elif line.startswith('CATEGORIES:'):
                in_summary = False
                in_description = False
                currentcategories = line
            elif line.startswith('UID:'):
                in_summary = False
                in_description = False
                currentuid= re.search(UID_REGEX, line).group(1)

            ## write completed event entry:
            elif line.startswith('END:VEVENT'):

                in_summary = False
                in_description = False
                description_lines = 0

                ## entry is finished
                if newentry and not dryrun:

                    if currentuid in known_uids:
                        omitted_events += 1

                    elif dtend_is_not_in_past(newentry):

                        newsummary = newlocation = newcategories = ""
                        known_uids.append(currentuid)

                        ## parse categories for known substrings
                        reminder, is_private = \
                            parse_categories_for_known_tags(currentcategories)

                        if is_private or obfuscate_everything:
                            logging.debug("is_private is True")
                            newsummary = u'SUMMARY:' + PRIVATE_SUMMARY
                            newlocation = ""
                            newcategories = ""
                            newdescription = ""
                        else:
                            newsummary = currentsummary
                            newdescription = currentdescription
                            newcategories = currentcategories
                            logging.debug("newsummary: [%s]" % newsummary)
                            logging.debug("newlocation: [%s]" % newlocation)
                            logging.debug("newcategories: [%s]" % newcategories)

                        output.write(newentry)  # entry so far without description, location, or end

                        output.write(newsummary + '\n')

                        ## if found, write location:
                        if newlocation:
                            output.write(newlocation + '\n')

                        ## if found, write description:
                        if newdescription:
                            output.write(newdescription + '\n')

                        ## if found, write categories:
                        if newcategories:
                            output.write(newcategories + '\n')

                        if reminder:
                            output.write(generate_reminder_entries(reminder))

                        ## write end of iCalendar entry
                        output.write(line + '\n')

                        ## reset entries:
                        currentsummary = ""
                        currentdescription = ""
                        currentcategories = ""
                        currentuid = ""
                        newentry = ""

                    else:
                        ## DTEND is in past!
                        omitted_events += 1
                        #logging.warning('DTEND of entry \"' + currentsummary + '\" is in past: ' + newentry)

                        ## reset entries:
                        currentsummary = ""
                        currentdescription = ""
                        currentcategories = ""
                        currentuid = ""
                        newentry = ""

            elif line.startswith('END:VCALENDAR'):
                output.write(line + '\n')

            ## lines that are identical in output:
            else:
                if in_description:
                    description_lines += 1
                    if description_lines <= MAX_DESCRIPTION_LINES:
                        currentdescription += line
                elif in_summary:
                    currentsummary += line
                else:
                    newline = line

            if parsing_header:
                newline = line

            if newline and not dryrun and not in_description:
                #output.write(newline + '\n')
                newentry += newline + '\n'

        return count_events, omitted_events


def main():
    """Main function"""

    if options.version:
        print os.path.basename(sys.argv[0]) + " version " + PROG_VERSION_NUMBER + " from " + PROG_VERSION_DATE
        sys.exit(0)

    handle_logging()
    dryrun = False

    if options.dryrun:
        logging.info("Option \"--dryrun\" found, running a simulation, not modifying anything on file system.")
        dryrun = True

    if not options.inputfilename and not options.outputfilename:
        error_exit(1, "Please give me an input file to parse \"--input\" and an output file to generate \"--output\".")

    if not options.inputfilename and options.outputfilename:
        error_exit(2, "Please give me an input file to parse \"--input\".")

    if options.inputfilename and not options.outputfilename:
        error_exit(3, "Please give me an output file to generate \"--output\".")

    logging.debug("dryrun: " + str(dryrun))

    ## make sure that outputfilename does not exist or handle situation:
    ## FIXXME: handle situation when outputfilename is a folder (and not a file)
    if os.path.exists(options.outputfilename):
        if options.overwrite:
            logging.debug("deleting old output file because of overwrite parameter")
            if not dryrun:
                os.remove(options.outputfilename)
            else:
                logging.debug("dryrun: I would delete the file \"%s\" now." % options.outputfilename)
        else:
            error_exit(4, "Sorry, output file \"%s\" already exists and you did not use the overwrite option \"--overwrite\"." % options.outputfilename)

    count_events, omitted_events = handle_file(options.inputfilename, options.outputfilename, dryrun, options.obfuscateeverything)

    logging.info("successfully finished converting %s events." % count_events)
    if omitted_events > 0:
        logging.info("wrote %s events, omitted %s events." % (count_events - omitted_events, omitted_events))


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:

        logging.info("Received KeyboardInterrupt")

## END OF FILE #################################################################

#end
