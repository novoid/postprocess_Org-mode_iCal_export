#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Time-stamp: <2024-03-23 13:40:51 vk>


# TODO:
# * fix parts marked with «FIXXME»
# * fix: all lines with no iCal tag followed by ':' are extended summary lines and should follow the summary line
# * write unit tests


# overrules enything else and shows only PRIVATE_SUMMARY and no location
PRIVATE_TAG = 'private'
PRIVATE_SUMMARY = 'busy'              # in case no special tag is found
MAX_DESCRIPTION_LINES = 10            # number of description lines (of input file) added to output

# ===================================================================== #
#  You might not want to modify anything below this line if you do not  #
#  know, what you are doing :-)                                         #
# ===================================================================== #

# NOTE: in case of issues, check iCalendar files using: http://icalvalid.cloudapp.net/

import os
import sys
import re
import time
import logging
from optparse import OptionParser
import hashlib  ## for md5

REMINDER_REGEX = re.compile("^rem(\d\d?)$")

TIMESTAMP_ROUGH_REGEX = re.compile("<.*>")
DTEND_REGEX = re.compile("\nDTEND(;VALUE=DATE)?:(.+)\n")
UID_REGEX = re.compile("UID:(.+)")

PROG_VERSION_NUMBER = "0.2"
PROG_VERSION_DATE = "2015-05-14"
INVOCATION_TIME = time.strftime("%Y-%m-%dT%H:%M:%S", time.localtime())
INVOCATION_DAY_STR = INVOCATION_TIME[:10]
INVOCATION_DAY_SHORTSTR = time.strftime("%Y%m%d", time.localtime())

USAGE = "\n\
    " + sys.argv[0] + " -i <inputfile.ics> -o <outputfile.ics>\n\
\n\
This script filters an iCalendar file generated by Emacs Org-mode.\n\
TODOs and entries whose DTEND is in the past are omitted.\n\
Only the first entry of identical UIDs are written.\n\
\n\
If the tag defined in PRIVATE_TAG is found, description, summary, and \n\
location gets replaced with PRIVATE_SUMMARY as summary.\n\
\n\
Additionally, if REMINDER_REGEX finds reminders in tags, a Google\n\
Calendar reminder VALARM is added.\n\
\n\
Please refer to README.org for further details.\n\
\n\
https://github.com/novoid/postprocess_Org-mode_iCal_export\n\
\n\
\n\
:copyright: (c) 2013 or later by Karl Voit <tools@Karl-Voit.at>\n\
:license: GPL v3 or any later version\n\
:bugreports: <tools@Karl-Voit.at>\n\
:version: " + PROG_VERSION_NUMBER + " from " + PROG_VERSION_DATE + "\n"

parser = OptionParser(usage=USAGE)

parser.add_option("-i", "--input", dest="inputfilename",
                  help="(path and) name of the iCalendar file to parse", metavar="FILE")

parser.add_option("-o", "--output", dest="outputfilename",
                  help="(path and) name of the iCalendar file where the result is written to", metavar="FILE")

parser.add_option("--updateinterval", dest="updateinterval",
                  help="Add an update interval according to the ical specs such as \"8H\" or \"1D\"", metavar="INTERVAL")

parser.add_option("--remove-summary-timestamps", dest="removesummarytimestamps", action="store_true",
                  help="Removes any time-stamps found in summary line descriptions.")

parser.add_option("--obfuscate", dest="obfuscateeverything", action="store_true",
                  help="Hides summaries, descriptions, and categories. Generates a simple free/busy iCalendar file.")

parser.add_option("--wholedayeventsarefreewhenobfuscate", dest="wholedayeventsarefreewhenobfuscate", action="store_true",
                  help="If set (and --obfuscate is also set), whole day events (no time but associated to a day) are not exported.")

parser.add_option("--dryrun", dest="dryrun", action="store_true",
                  help="Does not make any changes to the file system. Useful for testing behavior.")

parser.add_option("-O", "--overwrite", dest="overwrite", action="store_true",
                  help="Overwrite the output file without asking, if the output file exists.")

parser.add_option("-v", "--verbose", dest="verbose", action="store_true",
                  help="enable verbose mode")

parser.add_option("--version", dest="version", action="store_true",
                  help="display version and exit")

(options, args) = parser.parse_args()


def handle_logging():
    """Log handling and configuration"""

    if options.verbose:
        FORMAT = "%(levelname)-8s %(asctime)-15s %(message)s"
        logging.basicConfig(level=logging.DEBUG, format=FORMAT)
    else:
        FORMAT = "%(levelname)-8s %(message)s"
        logging.basicConfig(level=logging.INFO, format=FORMAT)


def error_exit(errorcode, text):
    """exits with return value of errorcode and prints to stderr"""

    sys.stdout.flush()
    logging.error(text)

    sys.exit(errorcode)


def parse_categories_for_known_tags(categories):
    """parse categories for pre-defined tags and generate new summary
    and is_private flag accordingly."""

    catlist = categories[11:].split(',')
    # logging.debug("catlist [%s]" % str(catlist) )

    is_private = False
    reminder = []

    if catlist:

        for tag in catlist:
            # logging.debug("tag [%s]" % tag )

            if PRIVATE_TAG == tag:
                is_private = True

            matching_reminder = re.match(REMINDER_REGEX, tag)
            if matching_reminder:

                reminder_minutes = matching_reminder.group(1)
                logging.debug("found reminder in tag [%s] with [%s] minutes" % (tag, reminder_minutes))
                reminder.append(reminder_minutes)

    return reminder, is_private


def generate_reminder_entries(reminderlist):
    """Generate iCalendar entries for each reminder in the list."""

    output = ""

    for reminder in reminderlist:
        output += "BEGIN:VALARM\nACTION:DISPLAY\nDESCRIPTION:This is an event reminder\n"
        output += "TRIGGER:-P0DT0H" + reminder.zfill(2) + "M0S\nEND:VALARM\n"

    return output


def dtend_is_not_in_past(entry):
    """returns true, if DTEND of VEVENT-string is today or in the future.
       Returns also true, if there is no DTEND entry."""

    matching_dtend = re.search(DTEND_REGEX, entry)
    if matching_dtend:
        return INVOCATION_DAY_SHORTSTR <= matching_dtend.group(2)[:8]
    else:
        return True


def handle_file(inputfilename, outputfilename, dryrun, obfuscate_everything, wholedayeventsarefreewhenobfuscate):
    """handles inputfile and generates outputfile"""

    logging.debug("--------------------------------------------")
    logging.info(sys.argv[0] + "   ... called with ... ")
    logging.info("inputfile file \"" + inputfilename + "\"  ... and ...")
    logging.info("output file \"" + outputfilename + "\"")

    parsing_header = True
    count_events = 0
    omitted_events = 0
    omitted_todos = 0
    newentry = ""
    currentsummary = ""
    currentdescription = ""
    currentcategories = ""
    currentuid = ""
    in_description = False
    in_summary = False
    description_lines = 0
    known_uids = []
    within_vevent = False

    with open(outputfilename, 'w') as output:

        inputfile = open(inputfilename, 'r')
        for rawline in inputfile:

            newline = ""
            line = rawline.strip()
            logging.debug("line: %s" % line)

            if parsing_header and not (line.startswith('BEGIN:VEVENT') or line.startswith('BEGIN:VTODO')):
                # header is written to the output as is:
                output.write(line + '\n')

            elif line.startswith('BEGIN:VTODO'):
                if parsing_header:
                    if options.updateinterval:
                        output.write('REFRESH-INTERVAL;VALUE=DURATION:PT' + options.updateinterval + '\n')
                    parsing_header = False
                            
                omitted_todos += 1

            elif line.startswith('END:VCALENDAR'):
                output.write(line + '\n')

            elif line.startswith('BEGIN:VEVENT') or within_vevent:
                # not parsing header any more:

                # detect new event (and header end)
                if not within_vevent and line.startswith('BEGIN:VEVENT'):

                    if parsing_header:
                        if options.updateinterval:
                            output.write('REFRESH-INTERVAL;VALUE=DURATION:PT' + options.updateinterval + '\n')
                        parsing_header = False
                            
                    logging.debug("new VEVENT .............................................")
                    count_events += 1
                    newline = line
                    in_description = False
                    in_summary = False
                    within_vevent = True

                    # reset entries:
                    currentsummary = ""
                    currentdescription = ""
                    currentcategories = ""
                    currentuid = ""
                    newentry = ""

                else:

                    # store content fields:
                    if line.startswith('SUMMARY:'):
                        in_description = False
                        in_summary = True
                        if options.removesummarytimestamps:
                            # removing any substrings enclosed in angle brackets (usually time-stamps):
                            currentsummary = TIMESTAMP_ROUGH_REGEX.sub('', line).replace("SUMMARY:  ", "SUMMARY: ")
                        else:
                            currentsummary = line
                    elif line.startswith('DESCRIPTION:'):
                        in_summary = False
                        in_description = True
                        description_lines = 1
                        currentdescription = line
                    elif line.startswith('CATEGORIES:'):
                        in_summary = False
                        in_description = False
                        currentcategories = line
                    elif line.startswith('UID:'):
                        in_summary = False
                        in_description = False
                        currentuid = re.search(UID_REGEX, line).group(1)

                    # write completed event entry:
                    elif line.startswith('END:VEVENT'):

                        in_summary = False
                        in_description = False
                        description_lines = 0
                        within_vevent = False

                        # entry is finished
                        if newentry and not dryrun:

                            if currentuid in known_uids:
                                omitted_events += 1

                            elif dtend_is_not_in_past(newentry):

                                newsummary = newlocation = newcategories = ""
                                known_uids.append(currentuid)

                                # parse categories for known substrings
                                reminder, is_private = \
                                    parse_categories_for_known_tags(currentcategories)

                                if is_private or obfuscate_everything:
                                    logging.debug("is_private is True")
                                    newsummary = 'SUMMARY:' + PRIVATE_SUMMARY
                                    newlocation = ""
                                    newcategories = ""
                                    newdescription = ""
                                else:
                                    newsummary = currentsummary
                                    newdescription = currentdescription
                                    newcategories = currentcategories
                                    logging.debug("newsummary: [%s]" % newsummary)
                                    logging.debug("newlocation: [%s]" % newlocation)
                                    logging.debug("newcategories: [%s]" % newcategories)

                                output.write(newentry)  # entry so far without description, location, or end

                                ## handle UIDs:
                                if is_private or obfuscate_everything:
                                    output.write('UID:' + hashlib.md5(currentuid.encode('utf-8')).hexdigest() + '\n')
                                else:
                                    output.write('UID:' + currentuid + '\n')

                                output.write(newsummary + '\n')

                                # if found, write location:
                                if newlocation:
                                    output.write(newlocation + '\n')

                                # if found, write description:
                                if newdescription:
                                    output.write(newdescription + '\n')

                                # if found, write categories:
                                if newcategories:
                                    output.write(newcategories + '\n')

                                if reminder:
                                    output.write(generate_reminder_entries(reminder))

                                # write end of iCalendar entry
                                output.write(line + '\n')

                            else:
                                # DTEND is in past!
                                omitted_events += 1
                                # logging.warning('DTEND of entry \"' + currentsummary + '\" is in past: ' + newentry)

                    # lines that are identical in output:
                    else:
                        if in_description:
                            description_lines += 1
                            if description_lines <= MAX_DESCRIPTION_LINES:
                                currentdescription += line
                        elif in_summary:
                            currentsummary += line
                        else:
                            # mark entry as non-busy when: (1) whole day event (2) obfuscate and (3) corresponding parameter set:
                            if line.startswith('DTEND;VALUE=DATE:') and \
                               obfuscate_everything and \
                               wholedayeventsarefreewhenobfuscate:
                                newline = line + '\nTRANSP:TRANSPARENT'
                            else:
                                newline = line

                if newline and not dryrun and not in_description:
                    newentry += newline + '\n'

        return count_events, omitted_events, omitted_todos


def main():
    """Main function"""

    if options.version:
        print(os.path.basename(sys.argv[0]) + " version " + PROG_VERSION_NUMBER + " from " + PROG_VERSION_DATE)
        sys.exit(0)

    handle_logging()
    dryrun = False

    if options.dryrun:
        logging.info("Option \"--dryrun\" found, running a simulation, not modifying anything on file system.")
        dryrun = True

    if not options.inputfilename and not options.outputfilename:
        error_exit(1, "Please give me an input file to parse \"--input\" and an output file to generate \"--output\".")

    if not options.inputfilename and options.outputfilename:
        error_exit(2, "Please give me an input file to parse \"--input\".")

    if options.inputfilename and not options.outputfilename:
        error_exit(3, "Please give me an output file to generate \"--output\".")

    logging.debug("dryrun: " + str(dryrun))

    # make sure that outputfilename does not exist or handle situation:
    # FIXXME: handle situation when outputfilename is a folder (and not a file)
    if os.path.exists(options.outputfilename):
        if options.overwrite:
            logging.debug("deleting old output file because of overwrite parameter")
            if not dryrun:
                os.remove(options.outputfilename)
            else:
                logging.debug("dryrun: I would delete the file \"%s\" now." % options.outputfilename)
        else:
            error_exit(4, "Sorry, output file \"%s\" already exists and you did not use the overwrite option \"--overwrite\"." % options.outputfilename)

    count_events, omitted_events, omitted_todos = handle_file(options.inputfilename,
                                                              options.outputfilename,
                                                              dryrun,
                                                              options.obfuscateeverything,
                                                              options.wholedayeventsarefreewhenobfuscate)

    logging.info("successfully finished converting %s events." % count_events)
    if omitted_events > 0:
        logging.info("wrote %s events, omitted %s events and %s todos." % (count_events - omitted_events, omitted_events, omitted_todos))


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:

        logging.info("Received KeyboardInterrupt")

# END OF FILE #################################################################
