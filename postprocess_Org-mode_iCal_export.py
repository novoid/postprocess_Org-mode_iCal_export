#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Time-stamp: <2013-12-13 21:04:35 vk>


## TODO:
## * fix parts marked with «FIXXME»
## * fix: all lines with no iCal tag followed by ':' are extended summary lines and should follow the summary line


## overrules enything else and shows only PRIVATE_SUMMARY and no location
PRIVATE_TAG = 'private'
PRIVATE_SUMMARY = 'busy'              ## in case no special tag is found
MAX_DESCRIPTION_LINES = 10            ## number of description lines (of input file) added to output

## ===================================================================== ##
##  You might not want to modify anything below this line if you do not  ##
##  know, what you are doing :-)                                         ##
## ===================================================================== ##

## NOTE: in case of issues, check iCalendar files using: http://icalvalid.cloudapp.net/

import os
import sys
import re
import time
import logging
from optparse import OptionParser

REMINDER_REGEX = re.compile("^rem(\d\d?)$")

TIMESTAMP_ROUGH_REGEX = re.compile("<.*>")

PROG_VERSION_NUMBER = u"0.1"
PROG_VERSION_DATE = u"2013-01-30"
INVOCATION_TIME = time.strftime("%Y-%m-%dT%H:%M:%S", time.localtime())

USAGE = u"\n\
    " + sys.argv[0] + u" -i <inputfile.ics> -o <outputfile.ics>\n\
\n\
This script filters an iCalendar file generated by Emacs Org-mode.\n\
If the tag defined in PRIVATE_TAG is found, description, summary, and \n\
location gets replaced with PRIVATE_SUMMARY as summary.\n\
Additionally, if REMINDER_REGEX finds reminders in tags, a Google\n\
Calendar reminder VALARM is added.\n\
\n\
Please refer to README.org for further details.\n\
\n\
https://github.com/novoid/postprocess_Org-mode_iCal_export\n\
\n\
\n\
:copyright: (c) 2013 by Karl Voit <tools@Karl-Voit.at>\n\
:license: GPL v3 or any later version\n\
:bugreports: <tools@Karl-Voit.at>\n\
:version: " + PROG_VERSION_NUMBER + " from " + PROG_VERSION_DATE + "\n"

parser = OptionParser(usage=USAGE)

parser.add_option("-i", "--input", dest="inputfilename",
                  help="(path and) name of the iCalendar file to parse", metavar="FILE")

parser.add_option("-o", "--output", dest="outputfilename",
                  help="(path and) name of the iCalendar file where the result is written to", metavar="FILE")

parser.add_option("--remove-summary-timestamps", dest="removesummarytimestamps", action="store_true",
                  help="Removes any time-stamps found in summary line descriptions.")

parser.add_option("--dryrun", dest="dryrun", action="store_true",
                  help="Does not make any changes to the file system. Useful for testing behavior.")

parser.add_option("-O", "--overwrite", dest="overwrite", action="store_true",
                  help="Overwrite the output file without asking, if the output file exists.")

parser.add_option("-v", "--verbose", dest="verbose", action="store_true",
                  help="enable verbose mode")

parser.add_option("--version", dest="version", action="store_true",
                  help="display version and exit")

(options, args) = parser.parse_args()


def handle_logging():
    """Log handling and configuration"""

    if options.verbose:
        FORMAT = "%(levelname)-8s %(asctime)-15s %(message)s"
        logging.basicConfig(level=logging.DEBUG, format=FORMAT)
    else:
        FORMAT = "%(levelname)-8s %(message)s"
        logging.basicConfig(level=logging.INFO, format=FORMAT)


def error_exit(errorcode, text):
    """exits with return value of errorcode and prints to stderr"""

    sys.stdout.flush()
    logging.error(text)

    sys.exit(errorcode)


def parse_categories_for_known_tags(categories):
    """parse categories for pre-defined tags and generate new summary
    and is_private flag accordingly."""

    catlist = categories[11:].split(',')
    #logging.debug("catlist [%s]" % str(catlist) )

    is_private = False
    reminder = []

    if catlist:

        for tag in catlist:
            #logging.debug("tag [%s]" % tag )

            if PRIVATE_TAG == tag:
                is_private = True

            matching_reminder = re.match(REMINDER_REGEX, tag)
            if matching_reminder:

                reminder_minutes = matching_reminder.group(1)
                logging.debug("found reminder in tag [%s] with [%s] minutes" % (tag, reminder_minutes))
                reminder.append(reminder_minutes)

    return reminder, is_private


def generate_reminder_entries(reminderlist):
    """Generate iCalendar entries for each reminder in the list."""

    output = ""

    for reminder in reminderlist:
        output += "BEGIN:VALARM\nACTION:DISPLAY\nDESCRIPTION:This is an event reminder\n"
        output += "TRIGGER:-P0DT0H" + reminder.zfill(2) + "M0S\nEND:VALARM\n"

    return output


def handle_file(inputfilename, outputfilename, dryrun):
    """handles inputfile and generates outputfile"""

    logging.debug("--------------------------------------------")
    logging.info(sys.argv[0] + "   ... called with ... ")
    logging.info("input file \"" + inputfilename + "\"  ... and ...")
    logging.info("output file \"" + outputfilename + "\"")

    parsing_header = True
    count_events = 0
    newentry = ""
    currentsummary = ""
    currentdescription = ""
    currentcategories = ""
    in_description = False
    in_summary = False
    description_lines = 0

    with open(outputfilename, 'w') as output:

        input = open(inputfilename, 'r')
        for rawline in input:

            newline = ""
            line = rawline.strip()
            logging.debug("line: %s" % line)

            ## detect new event (and header end)
            if line.startswith('BEGIN:VEVENT'):
                logging.debug("new VEVENT .............................................")
                count_events += 1
                newline = line
                in_description = False
                in_summary = False

                ## header is finished:
                if parsing_header and not dryrun:
                    output.write(newentry)
                    newentry = ""

                parsing_header = False

            ## store content fields:
            elif line.startswith('SUMMARY:'):
                in_description = False
                in_summary = True
                if options.removesummarytimestamps:
                    ## removing any substrings enclosed in angle brackets (usually time-stamps):
                    currentsummary = TIMESTAMP_ROUGH_REGEX.sub('', line).replace("SUMMARY:  ", "SUMMARY: ")
                else:
                    currentsummary = line
            elif line.startswith('DESCRIPTION:'):
                in_summary = False
                in_description = True
                description_lines = 1
                currentdescription = line
            elif line.startswith('CATEGORIES:'):
                in_summary = False
                in_description = False
                currentcategories = line

            ## write completed event entry:
            elif line.startswith('END:VEVENT'):

                in_summary = False
                in_description = False
                description_lines = 0

                ## entry is finished
                if newentry and not dryrun:

                    newsummary = newlocation = newcategories = ""

                    ## parse categories for known substrings
                    reminder, is_private = \
                        parse_categories_for_known_tags(currentcategories)

                    if is_private:
                        logging.debug("is_private is True")
                        newsummary = PRIVATE_SUMMARY
                        newlocation = ""
                        newcategories = ""
                    else:
                        newsummary = currentsummary
                        newdescription = currentdescription
                        newcategories = currentcategories
                        logging.debug("newsummary: [%s]" % newsummary)
                        logging.debug("newlocation: [%s]" % newlocation)
                        logging.debug("newcategories: [%s]" % newcategories)

                    output.write(newentry)  ## entry so far without description, location, or end

                    output.write(newsummary + '\n')

                    ## if found, write location:
                    if newlocation:
                        output.write(newlocation + '\n')

                    ## if found, write description:
                    if newdescription:
                        output.write(newdescription + '\n')

                    ## if found, write categories:
                    if newcategories:
                        output.write(newcategories + '\n')

                    if reminder:
                        output.write(generate_reminder_entries(reminder))

                    ## write end of iCalendar entry
                    output.write(line + '\n')

                    ## reset entries:
                    currentsummary = ""
                    currentdescription = ""
                    currentcategories = ""
                    newentry = ""

            elif line.startswith('END:VCALENDAR'):
                    output.write(line + '\n')

            ## lines that are identical in output:
            else:
                if in_description:
                    description_lines += 1
                    if description_lines <= MAX_DESCRIPTION_LINES:
                        currentdescription += line
                elif in_summary:
                    currentsummary += line
                else:
                    newline = line

            if parsing_header:
                newline = line

            if newline and not dryrun and not in_description:
                #output.write(newline + '\n')
                newentry += newline + '\n'

        return count_events


def main():
    """Main function"""

    if options.version:
        print os.path.basename(sys.argv[0]) + " version " + PROG_VERSION_NUMBER + " from " + PROG_VERSION_DATE
        sys.exit(0)

    handle_logging()
    dryrun = False

    if options.dryrun:
        logging.info("Option \"--dryrun\" found, running a simulation, not modifying anything on file system.")
        dryrun = True

    if not options.inputfilename and not options.outputfilename:
        error_exit(1, "Please give me an input file to parse \"--input\" and an output file to generate \"--output\".")

    if not options.inputfilename and options.outputfilename:
        error_exit(2, "Please give me an input file to parse \"--input\".")

    if options.inputfilename and not options.outputfilename:
        error_exit(3, "Please give me an output file to generate \"--output\".")

    logging.debug("dryrun: " + str(dryrun))

    ## make sure that outputfilename does not exist or handle situation:
    ## FIXXME: handle situation when outputfilename is a folder (and not a file)
    if os.path.exists(options.outputfilename):
        if options.overwrite:
            logging.debug("deleting old output file because of overwrite parameter")
            if not dryrun:
                os.remove(options.outputfilename)
            else:
                logging.debug("dryrun: I would delete the file \"%s\" now." % options.outputfilename)
        else:
            error_exit(4, "Sorry, output file \"%s\" already exists and you did not use the overwrite option \"--overwrite\"." % options.outputfilename)

    count_events = handle_file(options.inputfilename, options.outputfilename, dryrun)

    logging.info("successfully finished converting %s events." % count_events)


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:

        logging.info("Received KeyboardInterrupt")

## END OF FILE #################################################################

#end
